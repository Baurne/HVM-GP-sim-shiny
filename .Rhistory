print(n = 20)
length(unique(long_res$param))  # likely ~11
long_res %>% count(J, mj, Ti, param) %>% arrange(desc(n)) %>% print(n = 20)
# 3) launch it (will pick up long_res from your environment)
runApp(launch.browser = TRUE)
View(results)
View(long_res)
long_res %>%
long_res %>%
subset(param == "delta_v")
library(dplyr)
long_res %>%
subset(param == "delta_v")
test <- long_res %>%
subset(param == "delta_v") %>%
group_by(J, mj, Ti) %>%
summarise(
n_belowm5   = sum(estimate <= -5, na.rm = TRUE))
View(test)
test <- long_res %>%
subset(param == "delta_v") %>%
group_by(J, mj, Ti)
View(test)
test <- long_res %>%
subset(param == "delta_v", rep<101) %>%
group_by(J, mj, Ti)
View(test)
test <- long_res %>%
subset(param == "delta_v" & rep<101) %>%
group_by(J, mj, Ti)
test <- long_res %>%
subset(param == "delta_v" && rep<101)
View(results)
View(long_res)
View(test)
test1 <- test[100,]
View(test1)
test1 <- test[1:100,]
View(test1)
test1 <- subset(test, J==10 && mj== &&Ti==10)
test1 <- subset(test, J==10 && mj==3 && Ti==10)
test1 <- subset(test, J==10 && mj==3 && Ti==10)
?subset()
test1 <- subset(test, J==10 && mj==3)
subset(test, J==10 && mj==3)
test <- long_res %>%
subset(param == "delta_v")
test <- long_res %>%
subset(param == "delta_v" && J==10)
test1 <- subset(test, J==10)
View(test1)
# 3) launch it (will pick up long_res from your environment)
runApp(launch.browser = TRUE)
# Load libraries and set up parallel plan
library(MMP)
library(MASS)
library(dplyr)
library(purrr)
library(tidyr)
library(tibble)
library(progressr)
library(furrr)
library(future)
plan(multisession, workers = parallel::detectCores() - 1)
# Enable a simple text progress bar:
handlers("txtprogressbar")
# 1) Function for generating a dataset and fit a GP+GP model
run_one_sim <- function(J, mj, Ti,
mu0, mu1,
delta_group, sgp_group, k_group,#corr_group,
delta_indiv, sgp_indiv, k_indiv,#corr_indiv,
sigma2_e, sigma2_v0, sigma2_tau0,
seed) {
set.seed(seed)
time <- 1:Ti
Dist <- as.matrix(dist(time))
# — TRUE GP covariances —
#  k_group  <- max(Dist)/(-log(corr_group))
param_g  <- c(log(sqrt((2*(1/k_group))*sgp_group)), -log(k_group))
Sigma_g  <- OUcov(Dist, param_g)
covs_group_true <- diag(exp(delta_group * time)) %*% Sigma_g %*% diag(exp(delta_group * time))
#  k_indiv  <- max(Dist)/(-log(corr_indiv))
param_i  <- c(log(sqrt((2*(1/k_indiv))*sgp_indiv)), -log(k_indiv))
Sigma_i  <- OUcov(Dist, param_i)
covs_indiv_true <- diag(exp(delta_indiv * time)) %*% Sigma_i %*% diag(exp(delta_indiv * time))
# — TRUE full‐y covariance for one individual (person 1, group 1) —
cov_y_true <- covs_group_true +
covs_indiv_true +
matrix(sigma2_v0 + sigma2_tau0, Ti, Ti) +
diag(rep(sigma2_e, Ti))
# use tryCatch to track potential issues
out <- tryCatch({
# — Simulate one dataset —
mean_group <- mu0 + mu1 * time
g_group_mat <- MASS::mvrnorm(J, mu = mean_group, Sigma = covs_group_true)
gpdat_group <- tibble(
group   = rep(1:J, each = Ti),
time    = rep(time, J),
g_group = as.vector(t(g_group_mat))
)
total_indiv <- J * mj
mean_indiv  <- rep(0, Ti)
g_indiv_mat <- MASS::mvrnorm(total_indiv, mu = mean_indiv, Sigma = covs_indiv_true)
gpdat_indiv <- tibble(
id_full = rep(1:total_indiv, each = Ti),
time    = rep(time, total_indiv),
g_indiv = as.vector(t(g_indiv_mat))
)
dat <- expand.grid(time = time, person = 1:mj, group = 1:J) %>%
arrange(group, person, time) %>%
mutate(id_full = (group - 1) * mj + person) %>%
left_join(gpdat_group,  by = c("group", "time")) %>%
left_join(gpdat_indiv,  by = c("id_full", "time")) %>%
mutate(
v0ij  = rnorm(total_indiv, 0, sqrt(sigma2_v0))[id_full],
tau0j = rnorm(J,            0, sqrt(sigma2_tau0))[group],
eps   = rnorm(n(),          0, sqrt(sigma2_e)),
y     = g_group + tau0j + v0ij + g_indiv + eps
)
# — Fit the GP model —
GP.h <- ce(
y ~ 1 + time,
~ 1 | person,
~ 1 | group,
emergence   = ~ 1,
method      = "GP",
method.team = "OU.homeostasis",
time        = "time",
data        = dat
)
# — Extract estimates —
betas           <- GP.h$betas
sigma2_v0_est   <- exp(2 * GP.h$covariances$indv[[1]])
sigma2_v1_est   <- exp(2 * GP.h$covariances$indv[[2]][2] -
GP.h$covariances$indv[[2]][3]) / 2
delta_v_est     <- GP.h$covariances$indv[[2]][1]
kappa_v_est     <- exp(-GP.h$covariances$indv[[2]][3])
corr_v_est      <- exp(-max(Dist) / kappa_v_est)
sigma2_tau0_est <- exp(2 * GP.h$covariances$team[[1]])
sigma2_tau1_est <- exp(2 * GP.h$covariances$team[[2]][2] -
GP.h$covariances$team[[2]][3]) / 2
delta_tau_est   <- GP.h$covariances$team[[2]][1]
kappa_tau_est   <- exp(-GP.h$covariances$team[[2]][3])
corr_tau_est    <- exp(-max(Dist) / kappa_tau_est)
sigma2_e_est    <- exp(2 * GP.h$covariances$error[[1]])
# — REBUILD estimated GP covariances —
param_g_est    <- c(log(sqrt((2*(1/kappa_tau_est))*sigma2_tau1_est)), -log(kappa_tau_est))
Sigma_g_est    <- OUcov(Dist, param_g_est)
covs_group_est <- diag(exp(delta_tau_est * time)) %*% Sigma_g_est %*% diag(exp(delta_tau_est * time))
param_i_est     <- c(log(sqrt((2*(1/kappa_v_est))*sigma2_v1_est)), -log(kappa_v_est))
Sigma_i_est     <- OUcov(Dist, param_i_est)
covs_indiv_est  <- diag(exp(delta_v_est * time)) %*% Sigma_i_est %*% diag(exp(delta_v_est * time))
# — REBUILD estimated full‐y covariance (person 1, group 1) —
cov_y_est <- covs_group_est +
covs_indiv_est +
matrix(sigma2_v0_est + sigma2_tau0_est, Ti, Ti) +
diag(rep(sigma2_e_est, Ti))
# — Return all true & estimated covariances + seed & scalars —
tibble(
seed             = seed,
beta0_est        = betas[1],
beta1_est        = betas[2],
sigma2_v0_est    = sigma2_v0_est,
sigma2_v1_est    = sigma2_v1_est,
delta_v_est      = delta_v_est,
kappa_v_est      = kappa_v_est,
corr_v_est       = corr_v_est,
sigma2_tau0_est  = sigma2_tau0_est,
sigma2_tau1_est  = sigma2_tau1_est,
delta_tau_est    = delta_tau_est,
kappa_tau_est    = kappa_tau_est,
corr_tau_est     = corr_tau_est,
sigma2_e_est     = sigma2_e_est,
covs_group_true  = list(covs_group_true),
covs_indiv_true  = list(covs_indiv_true),
cov_y_true       = list(cov_y_true),
covs_group_est   = list(covs_group_est),
covs_indiv_est   = list(covs_indiv_est),
cov_y_est        = list(cov_y_est)
)
}, error = function(e){
# This runs only if any error is thrown above
tibble(
failed         = TRUE,
seed           = seed,
beta0_est      = NA_real_,
beta1_est      = NA_real_,
sigma2_v0_est  = NA_real_,
sigma2_v1_est    = NA_real_,
delta_v_est      = NA_real_,
kappa_v_est      = NA_real_,
corr_v_est       = NA_real_,
sigma2_tau0_est  = NA_real_,
sigma2_tau1_est  = NA_real_,
delta_tau_est    = NA_real_,
kappa_tau_est    = NA_real_,
corr_tau_est     = NA_real_,
sigma2_e_est     = NA_real_,
covs_group_true  = list(NULL),
covs_indiv_true  = list(NULL),
cov_y_true       = list(NULL),
covs_group_est   = list(NULL),
covs_indiv_est   = list(NULL),
cov_y_est        = list(NULL)
)
})
return(out)
}
# 2) Design grid, true params & seeds
J_vals  <- c(4, 10, 40)
mj_vals <- c(3, 5, 7)
Ti_vals <- c(4, 10)
param_grid <- expand.grid(J = J_vals, mj = mj_vals, Ti = Ti_vals) %>%
mutate(design_id = row_number())
# parameters from Cohesion application
true_params <- list(
mu0         = 1.001582e+00,
mu1         = -2.191354e-02,
delta_group = 8.124248e-02,
sgp_group   = 1.694252e-02,
#  corr_group  = 3.963931e-01,
k_group     = 3.244458e+00,
delta_indiv = 1.699087e-01,
sgp_indiv   = 6.894795e-03,
#  corr_indiv  = 5.077924e-01,
k_indiv     = 4.446048e+00,
sigma2_e    = 2.179537e-04,
sigma2_v0   = 1.290276e-07,
sigma2_tau0 = 9.128659e-25
)
n_sims <- 5 #100
set.seed(2025)
seeds  <- sample.int(.Machine$integer.max, n_sims * nrow(param_grid))
# 3) Build “long” sim grid with explicit seed assignment
sim_grid <- param_grid %>%
tidyr::crossing(rep = seq_len(n_sims)) %>%
mutate(seed = seeds[(design_id - 1) * n_sims + rep])
# record start
start_time <- Sys.time()
message("Simulation started at: ", format(start_time, "%Y-%m-%d %H:%M:%S"))
# Wrap parallel call in with_progress() for progress tracking
with_progress({
# create a progressor that knows the total number of iterations:
prog <- progressor(steps = nrow(sim_grid))
results <- future_pmap_dfr(
sim_grid,
function(J, mj, Ti, design_id, rep, seed) {
# tick the progress bar once per call
prog()
run_one_sim(
J             = J,
mj            = mj,
Ti            = Ti,
mu0           = true_params$mu0,
mu1           = true_params$mu1,
delta_group   = true_params$delta_group,
sgp_group     = true_params$sgp_group,
#      corr_group    = true_params$corr_group,
k_group      = true_params$k_group,
delta_indiv   = true_params$delta_indiv,
sgp_indiv     = true_params$sgp_indiv,
#      corr_indiv    = true_params$corr_indiv,
k_indiv     = true_params$k_indiv,
sigma2_e      = true_params$sigma2_e,
sigma2_v0     = true_params$sigma2_v0,
sigma2_tau0   = true_params$sigma2_tau0,
seed          = seed
) %>%
mutate(J = J, mj = mj, Ti = Ti, rep = rep)
},
.options = furrr_options(seed = NULL) # ignore warnings, we set our own seed
)
})
# record end
end_time <- Sys.time()
message("Simulation finished at: ", format(end_time, "%Y-%m-%d %H:%M:%S"))
# compute and print duration
duration <- difftime(end_time, start_time, units = "auto")
message("Total elapsed time: ", duration)
# Helper to get true parameter per design
get_true <- function(param, Ti) {
maxDist <- Ti - 1  # time grid 0:(Ti-1)
switch(param,
beta0       = true_params$mu0,
beta1       = true_params$mu1,
sigma2_v0   = true_params$sigma2_v0,
sigma2_v1   = true_params$sgp_indiv,
delta_v     = true_params$delta_indiv,
kappa_v     = true_params$k_indiv,
#kappa_v     = maxDist / (-log(true_params$corr_indiv)),
#  corr_v      = exp(-maxDist/true_params$k_indiv),
sigma2_tau0 = true_params$sigma2_tau0,
sigma2_tau1 = true_params$sgp_group,
delta_tau   = true_params$delta_group,
kappa_tau   = true_params$k_group,
# kappa_tau   = maxDist / (-log(true_params$corr_group)),
#  corr_tau    = exp(-maxDist/true_params$k_group),
sigma2_e    = true_params$sigma2_e,
NA_real_)
}
# Reshape and attach true values
long_res <- results %>%
pivot_longer(
cols = matches("^(beta|sigma2_|delta_|kappa_).*_est$"),
names_to = "param",
values_to = "estimate"
) %>%
mutate(
param = sub("_est$", "", param),
true  = map2_dbl(param, Ti, get_true)
)
# Summarise metrics by design and parameter
summary_results <- long_res %>%
group_by(J, mj, Ti, param) %>%
summarise(
bias       = mean(estimate - true, na.rm = T),
emp_se     = sd(estimate, na.rm = T),
rmse       = sqrt(mean((estimate - true)^2, na.rm = T)),
median_est = median(estimate, na.rm = T),
var_6633   = (quantile(estimate, 0.66, na.rm = T) - quantile(estimate, 0.33,na.rm = T)) / 2,
perc0.25  = quantile(estimate, 0.25, na.rm = T),
perc0.50  = quantile(estimate, 0.50, na.rm = T),
perc0.75  = quantile(estimate, 0.75, na.rm = T),
n          = n(),
#    failed     = sum(failed,na.rm = T)/n,
.groups    = "drop"
)
# Example display
summary_results %>%
filter(param == "kappa_v") %>%
arrange(J, mj, Ti)
View(long_res)
summary_results <- long_res %>%
group_by(J, mj, Ti, param) %>%
summarise(
smalls     = sum(estimate < -5)
n          = n(),
summary_results <- long_res %>%
group_by(J, mj, Ti, param) %>%
summarise(
smalls     = sum(estimate < -5),
n          = n(),
#    failed     = sum(failed,na.rm = T)/n,
.groups    = "drop"
)
View(summary_results)
summary_results <- long_res %>%
group_by(J, mj, Ti, param) %>%
summarise(
smalls     = sum(estimate < -5, na.rm=T),
n          = n(),
#    failed     = sum(failed,na.rm = T)/n,
.groups    = "drop"
)
View(summary_results)
View(long_res)
# 3) launch it (will pick up long_res from your environment)
runApp(launch.browser = TRUE)
# 3) launch it (will pick up long_res from your environment)
runApp(launch.browser = TRUE)
exp(-5)
exp(-5*5)
exp(-5*1)
exp(-5*2)
# Custom Σ_tau function
make_Sigma_tau <- function(tvec) {
Ti <- matrix(tvec, nrow = length(tvec), ncol = length(tvec))
Tj <- t(Ti)
m  <- pmin(Ti, Tj)
M  <- pmax(Ti, Tj)
1 + (1 / (2 * sqrt(Ti * Tj))) * (3 * (m^2) * M - m^3)
}
# Time points (start at 1 to avoid division by zero)
t_all <- 1:20
Sigma_tau <- make_Sigma_tau(t_all)
# Extract covariances and distances
cov_df <- expand.grid(i = 1:length(t_all), j = 1:length(t_all))
cov_df$ti <- t_all[cov_df$i]
cov_df$tj <- t_all[cov_df$j]
cov_df$distance <- abs(cov_df$ti - cov_df$tj)
cov_df$covariance <- as.vector(Sigma_tau)
# Plot covariance vs. distance
ggplot(cov_df, aes(x = distance, y = covariance)) +
geom_point(alpha = 0.3) +
stat_summary(fun = mean, geom = "line", color = "blue", size = 1) +
labs(
title = "Covariance vs. Distance between Time Points",
x = "|t_i - t_j| (distance)",
y = "Covariance"
) +
theme_minimal(base_size = 12)
# Custom Σ_tau function
make_Sigma_tau <- function(tvec) {
Ti <- matrix(tvec, nrow = length(tvec), ncol = length(tvec))
Tj <- t(Ti)
m  <- pmin(Ti, Tj)
M  <- pmax(Ti, Tj)
1 + (1 / (2 * sqrt(Ti * Tj))) * (3 * (m^2) * M - m^3)
}
# Time points
t_all <- 1:20
Sigma_tau <- make_Sigma_tau(t_all)
# Compute correlation matrix
sd_tau <- sqrt(diag(Sigma_tau))
Corr_tau <- Sigma_tau / (sd_tau %o% sd_tau)
# Extract into long format
mat_to_df <- function(mat, tvec) {
df <- expand.grid(i = 1:length(tvec), j = 1:length(tvec))
df$ti <- tvec[df$i]
df$tj <- tvec[df$j]
df$distance <- abs(df$ti - df$tj)
df$value <- as.vector(mat)
df
}
cov_df <- mat_to_df(Sigma_tau, t_all)
colnames(cov_df)[which(names(cov_df) == "value")] <- "covariance"
cor_df <- mat_to_df(Corr_tau, t_all)
colnames(cor_df)[which(names(cor_df) == "value")] <- "correlation"
# Plot: Covariance vs distance
p_cov <- ggplot(cov_df, aes(x = distance, y = covariance)) +
geom_point(alpha = 0.3) +
stat_summary(fun = mean, geom = "line", color = "blue", size = 1) +
labs(
title = "Covariance vs. Distance between Time Points",
x = "|t_i - t_j|",
y = "Covariance"
) +
theme_minimal(base_size = 12)
# Plot: Correlation vs distance
p_cor <- ggplot(cor_df, aes(x = distance, y = correlation)) +
geom_point(alpha = 0.3) +
stat_summary(fun = mean, geom = "line", color = "red", size = 1) +
labs(
title = "Correlation vs. Distance between Time Points",
x = "|t_i - t_j|",
y = "Correlation"
) +
theme_minimal(base_size = 12)
# Heatmap of correlation matrix
library(reshape2)
cor_long <- melt(Corr_tau)
colnames(cor_long) <- c("i", "j", "correlation")
p_heat <- ggplot(cor_long, aes(x = j, y = i, fill = correlation)) +
geom_tile() +
scale_fill_viridis_c(option = "plasma") +
labs(
title = "Correlation Matrix Heatmap",
x = "Time j",
y = "Time i",
fill = "Correlation"
) +
coord_equal() +
theme_minimal(base_size = 12)
# Display plots
p_cov
p_cor
p_heat
View(sim_grid)
# load your simulation results
results  <- readRDS("data/results.rds")
View(results)
View(long_res)
###########################
#File starts
data("cohesiondat")
View(cohesiondat)
#compute the eigenvalues and eigenvectors of the correlation matrix
SigmaE <- eigen(cov2cor(cov(cohesiondat[,4:6],use="complete")))
cat('largest eigenvalue explains =',100*round(SigmaE$values[1]/sum(SigmaE$values),2),'% of the variability\n')
cat('the corresponding eigenvector is:', round(SigmaE$vectors[,1],2),'\n')
cohesiondat$y <- rowMeans(scale(cohesiondat[,4:6], center = FALSE))
#######
# Figure 5
######
group.id <- unique(cohesiondat$group)
data.vis <- cohesiondat[cohesiondat$group%in%group.id[21:30],]
pl1 <- ggplot(data=data.vis,
aes(x=time,y=y, linetype = factor(person))) +
geom_line(size=0.5) + xlab("Time") + ylab("Cohesion") +
guides(linetype=guide_legend(title="Subjects within each group"))
pl1 <- pl1 +  facet_wrap(~group, ncol = 5) +
theme_bw() +
theme(legend.position="bottom") +
theme(legend.text=element_text(size=12),
legend.title=element_text(size=12),
#axis.text.x = element_text(size = 11),
#axis.text.y = element_text(size = 11),
axis.title.x = element_text(size = 12),
axis.title.y = element_text(size = 12))
print(pl1)
####
# Fitting all the models parameters
# (using known starting point to improve speed of convergence)
###
par.null  <- c(-4.2122558, -2.4602522, -4.8964796, -2.0860085, -2.9267910, -0.0183323)
null.model <- ce(y ~ 1+time,
~ 1 | person,
~ 1 + time | group,
emergence = ~ 1,
method = "CEM2",
data = cohesiondat,
param = par.null)
Sigma.null <- get.Cov(null.model$covariances, null.model$object)
par.CEM  <- c(-3.81459831, -2.46355658, -27.31109528,   6.81364972,
-2.08420523,  -2.92549732,  -0.01843801)
CEM.hem <- ce(y ~ 1+time,
~ 1 | person,
~ 1 + time | group,
emergence = ~ 1+time,
method = "CEM2",
data = cohesiondat,
param = par.CEM)
